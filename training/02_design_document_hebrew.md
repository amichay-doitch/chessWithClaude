# מסמך דיזיין - מנוע שחמט מבוסס למידה

## 1. סקירה כללית
[תיאור קצר של המטרה והגישה]

---

## 2. נתונים (Data)

### 2.1 מבנה הנתונים
[מה כל רשומה מכילה]

### 2.2 איסוף נתונים
[איך נייצר משחקים]

### 2.3 כמות נתונים
[כמה משחקים צריך, מתי נייצר עוד]

---

## 3. פיצ'רים (Feature Engineering)

### 3.1 פיצ'רי חומר
- ספירת כלים לפי סוג (רגלי, פרש, רץ, צריח, מלכה) לכל צד
- יתרון חומר כולל
- **טבלאות כלי-משבצת (PSQT)** - ערך הכלי תלוי במיקום (פרש במרכז > בפינה, צריח על טור פתוח, וכו')
- חוסר איזון חומרי (זוג רצים מול פרש+רגלים, מלכה מול 2 צריחים, וכו')

### 3.2 מבנה רגלים
- רגלים כפולים (שני רגלים על אותו טור)
- רגלים מבודדים (אין רגלים ידידותיים בטורים סמוכים)
- רגלים מקושרים (רגלים שמגנים זה על זה)
- רגלים עוברים (אין רגלי יריב חוסמים או תוקפים)
- **רגלים אחוריים** - רגלים שמאחורי אחרים ולא יכולים להתקדם בבטחה (חולשה סטטית)
- **איי רגלים** - מספר קבוצות רגלים מנותקות (פחות = מבנה חזק יותר)
- פוטנציאל הכתרה (מרחק לשורה 8)
- **חוק הריבוע** - האם המלך יכול לתפוס רגלי עובר? (סיום)

### 3.3 פעילות כלים
- שליטה במרכז (משבצות מרכזיות מאוימות)
- ניידות כלים (מהלכים חוקיים לכל כלי)
- עמדות מבוצרות (כלים על משבצות שלא יכולים להיות מאוימים ע"י רגלי יריב)
- כלים נעוצים (לא יכולים לזוז מבלי לחשוף כלי יקר יותר)
- **צריחים מקושרים** (צריחים שמגנים זה על זה על אותה שורה/טור)
- **רץ על אלכסון ארוך** - שליטה באלכסונים מרכזיים
- **רץ בפיאנקטו** - רץ שפותח ל-b2/g2/b7/g7
- פרשים/רצים במרכז מול בפינות
- כלים שיצאו מהשורה האחורית
- **פעילות מלכה** - ממורכזת מול בקצה

### 3.4 בטיחות המלך
- זכויות הצרחה (עדיין יכול להצריח קצר/ארוך)
- מיקום המלך (מוגן בפינה מול חשוף במרכז)
- כלים שמגנים על אזור המלך
- כלי יריב שתוקפים את אזור המלך
- **מגן רגלים** - רגלים מול מלך שהצריח (כמה, מבנה)
- **סערת רגלים** - רגלי יריב מתקדמים לכיוון המלך
- **טורים/אלכסונים פתוחים לכיוון המלך** - וקטורי תקיפה
- **משבצות בריחה למלך** - משבצות בטוחות למלך לברוח

### 3.5 שלב המשחק
- פתיחה / אמצע משחק / סיום (לפי כמות חומר)
- מספר המהלך
- **פעילות המלך** (בסיום, מלך פעיל קריטי)
- **אופוזיציה** - מיקומי מלכים בסיומי רגלים

### 3.6 איומים והתקפות
- בשח?
- כלים תחת איום
- כלים שתוקפים כלי יריב
- **טמפו / יוזמה** - מי תוקף, מי מתגונן

### 3.7 טקטיקות
- מזלגות (כלי שתוקף 2+ כלי יריב)
- שיפודים (תקיפה דרך כלי יקר לכלי מאחוריו)
- התקפות גילוי (הזזת כלי חושפת התקפה מכלי אחר)
- שח כפול (שני כלים נותנים שח)
- כלים לכודים (אין משבצות בריחה בטוחות)
- כלים תלויים (לא מוגנים, אפשר לאכול בחינם)
- התקפות רנטגן (התקפות דרך כלים לאורך קווים)
- **התקפות סוללה** - שני צריחים על אותו טור, או מלכה+צריח, מלכה+רץ על אלכסון
- **כלים עמוסים** - כלי שמגן על יותר מדי דברים

### 3.8 פיצ'רים אסטרטגיים

**למודל 1 (למידה קלאסית) - פיצ'רים ברורים וניתנים לספירה:**
- עמדה פתוחה מול סגורה (מספר טורים פתוחים/חצי-פתוחים)
- יתרון זוג רצים
- צריח על טור פתוח / שורה 7
- יתרון מרחב (משבצות נשלטות מעבר לשורה 4)
- רוב רגלים (בצד המלך/המלכה)
- שליטה בטורים פתוחים/חצי-פתוחים
- **שליטה בקומפלקס צבע** - שליטה במשבצות בהירות/כהות

**למודל 2 (רשת נוירונים) - דפוסים ניואנסיים יותר:**
- רץ טוב מול רץ רע (רגלים חוסמים את צבע הרץ)
- תיאום כלים (כלים שתומכים זה בזה)
- משבצות חלשות (לא ניתנות להגנה ע"י רגלים)
- חסימה (כלי שחוסם רגלי עובר)
- פרש מול רץ (מה עדיף בעמדה הנוכחית)

*הערה: רשת נוירונים יכולה ללמוד דפוסים עדינים מייצוג הלוח הגולמי. למידה קלאסית דורשת הנדסת פיצ'רים מפורשת.*

### 3.9 פיצ'רים דינמיים
- ספירת חזרות (מתקרבים לתיקו?)
- מונה 50 מהלכים
- המהלך האחרון היה אכילה/שח? (מומנטום)
- מי לזוז (טמפו)

### 3.10 ייצוג הלוח

**למודל 1 (למידה קלאסית):**
- וקטור פיצ'רים של כל הנ"ל (חלק בינאריים, חלק מספריים)
- סה"כ ~50-100 פיצ'רים

**למודל 2 (רשת נוירונים):**
- מישורי קלט כמו AlphaZero (8x8x12 ערוצים לכלים)
- היסטוריית עמדות (לזיהוי חזרות)
- **פיצ'רי HalfKP** (מיקום מלך + מיקומי כלים יחסית למלך) - בשימוש ב-Stockfish NNUE

---

## 4. מודל 1 - למידה קלאסית

### 4.1 ארכיטקטורה

שני מודלי **Gradient Boosting** נפרדים (תבנית Actor-Critic):
- **מודל Actor** - לבחירת מהלך (Policy)
- **מודל Critic** - להערכת פוזיציה (Value)

למה Gradient Boosting:
- עובד טוב עם פיצ'רים שנבנו ידנית
- הסקה מהירה (חשוב למשחק בזמן אמת)
- קל לפרש ולדבג
- לא דורש GPU

### 4.2 Policy (בחירת מהלך) - Actor

**קלט:** וקטור פיצ'רים של הפוזיציה הנוכחית + מהלך מועמד
**פלט:** ציון כמה טוב המהלך הזה

**איך זה עובד:**
1. מייצרים את כל המהלכים החוקיים
2. לכל מהלך, יוצרים פיצ'רים של הפוזיציה שתתקבל
3. Actor מדרג כל זוג (פוזיציה, מהלך)
4. בוחרים את המהלך עם הציון הגבוה ביותר (או דוגמים הסתברותית לחקירה)

**אימון:**
- מהלכים ממשחקים שניצחנו מקבלים סיגנל חיובי
- מהלכים ממשחקים שהפסדנו מקבלים סיגנל שלילי
- ההערכה של Critic עוזרת לחדד את הסיגנל

### 4.3 Value (הערכת פוזיציה) - Critic

**קלט:** וקטור פיצ'רים של פוזיציה
**פלט:** מספר בין 0-1 (תוצאה צפויה מפוזיציה זו)

**איך זה עובד:**
1. מחלצים פיצ'רים מהפוזיציה הנוכחית
2. Critic מוציא הערכה (0 = מפסיד, 0.5 = שווה, 1 = מנצח)

**אימון:**
- למידת TD(λ) - עדכון לפי ההפרש בין הערך החזוי לתוצאה בפועל
- לומדים מתוצאות משחקים, מפיצים אחורה דרך הפוזיציות

### 4.4 אימון

**לולאת אימון:**
1. משחקים משחקים עם Actor הנוכחי (עם חקירה)
2. אוספים טאפלים של (פוזיציה, מהלך, תוצאה)
3. מעדכנים Critic בלמידת TD על ערכי פוזיציות
4. מעדכנים Actor לפי הפידבק של Critic על איכות המהלכים
5. חוזרים

---

## 5. מודל 2 - רשת נוירונים

### 5.1 ארכיטקטורה
[מבנה הרשת]

### 5.2 רשת Policy
[רשת לבחירת מהלך]

### 5.3 רשת Value
[רשת להערכת פוזיציה]

### 5.4 אימון
[תהליך האימון]

---

## 6. למידת חיזוק (Reinforcement Learning)

### 6.1 אלגוריתם: Actor-Critic

אנחנו משתמשים ב-**Actor-Critic** - שני מודלים שעובדים יחד:

**Actor (השחקן - Policy):**
- בוחר מהלכים
- "מה המהלך הטוב?"

**Critic (המבקר - Value):**
- מעריך פוזיציות
- "כמה טובה הפוזיציה הזו?"

**איך הם עובדים יחד:**
1. Actor בוחר מהלך
2. מגיעים לפוזיציה חדשה
3. Critic מעריך: "הפוזיציה החדשה טובה יותר/גרועה יותר ממה שציפיתי"
4. Actor לומד: "המהלך שבחרתי היה טוב/רע" (לפי הפידבק של Critic)
5. Critic לומד: "ההערכה שלי הייתה מדויקת/לא מדויקת" (לפי תוצאת המשחק)

**למה Actor-Critic:**
- Actor לא צריך לחכות לסוף המשחק כדי ללמוד
- Critic נותן פידבק מיידי על כל מהלך
- פותר את בעיית הקרדיט - אם Critic אומר "הפוזיציה נהיתה גרועה", Actor יודע שהמהלך האחרון היה רע

### 6.2 תגמול (Reward)

**תגמול דליל (רק תוצאת משחק):**
- ניצחון = 1, הפסד = 0, תיקו = 0.5
- ללא תגמולי ביניים

**בעיית הקרדיט (Credit Assignment):**
- משחק נגמר בהפסד אחרי 40 מהלכים
- מהלך 5 היה מצוין, מהלך 35 היה הטעות
- שניהם מקבלים "תווית" של הפסד

**פתרון:** ה-Critic פותר את זה על ידי לימוד ערכי פוזיציות לאורך משחקים רבים. מהלכים טובים יופיעו בפוזיציות מנצחות לעתים קרובות יותר, מהלכים רעים בפוזיציות מפסידות.

### 6.3 משחק עצמי (Self-play)

המודל משתפר על ידי משחק נגד עצמו:

1. **המודל הטוב ביותר הנוכחי** משחק גם כלבן וגם כשחור
2. המשחקים כוללים **חקירה** (לא תמיד בוחרים את המהלך ה"טוב ביותר")
3. כל הפוזיציות והמהלכים נרשמים
4. אחרי אצווה של משחקים, המודלים מתעדכנים
5. המודל החדש הופך ל"טוב ביותר נוכחי" אם הוא חזק יותר

**אסטרטגיות חקירה:**
- ε-greedy: בהסתברות ε, בוחרים מהלך אקראי במקום הטוב ביותר
- Softmax: דוגמים מהלכים פרופורציונלית לציון שלהם
- הוספת רעש להערכות

### 6.4 לולאת האימון

**איטרציית אימון מלאה:**

```
1. שלב משחק (PLAY)
   - משחקים N משחקים (self-play)
   - רושמים: (פוזיציה, מהלך, תוצאת_משחק) לכל מהלך

2. שלב למידה (LEARN)
   - עדכון Critic:
     * לכל פוזיציה, יעד = תוצאת המשחק בפועל
     * מזעור שגיאת החיזוי באמצעות TD(λ)
   - עדכון Actor:
     * לכל (פוזיציה, מהלך), מחשבים יתרון = Critic(פוזיציה_חדשה) - Critic(פוזיציה_ישנה)
     * אם יתרון > 0: מחזקים את המהלך הזה
     * אם יתרון < 0: מחלישים את המהלך הזה

3. שלב הערכה (EVALUATE)
   - המודל החדש משחק נגד המודל הישן
   - אם אחוז ניצחון > סף: מקבלים את המודל החדש
   - אחרת: שומרים את המודל הישן

4. חוזרים
```

**היפרפרמטרים מרכזיים:**
- משחקים לכל איטרציה
- קצב למידה
- קצב חקירה (יורד עם הזמן)
- ערך למבדא ב-TD(λ)

---

## 7. אינטגרציה עם המערכת

### 7.1 ממשק Engine
[איך המנוע החדש משתלב ב-engine pool]

### 7.2 שמירת מודלים
[איך שומרים וטוענים מודלים]

---

## 8. הערכה ומדידה

### 8.1 מדדים
[איך נמדוד הצלחה]

### 8.2 טורנירים
[משחקים נגד מנועים אחרים]

---

## 9. שלבי פיתוח

### שלב 1: [תיאור]
### שלב 2: [תיאור]
### שלב 3: [תיאור]

---

## 10. שאלות פתוחות
[דברים שצריך להחליט]
